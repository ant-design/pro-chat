---
title: Detailed Explanation of API Core Request
group:
  title: Use Cases
  order: 10
nav:
  title: Documentation
  order: 0
---

# Detailed Explanation of API Core Request

First and foremost, it's important to understand that the core of ProChat is actually the data maintenance scheme. We follow the Data-Modal logic for rendering UI.

Therefore, you will also find that we have configured `chatItemRenderConfig` to help you render each chat unit in ProChat.

### Simple Usage

For simple conversation methods, basic String rendering is sufficient. This is how we initially designed it in the Request.

```js
<ProChat
  request={async (messages) => {
    const text = await delay(
      `This is a simulated non-streaming message output. This session received ${messages.length} messages`,
    );
    return new Response(text);
  }}
/>
```

Since we need to design compatibility with both SSE and regular output simultaneously, we require users to return the Response from this request back to us.

This raises a question: What if users want to return additional information for a particular data stream? For example, if they want to control parameters like id or createTime? Or even role?

> These parameters are automatically generated by ProChat by default; role defaults to user and assistant.

Although we've provided some hooks like `setMessageContent` that allow programmatic content modification, it's obviously not ideal for users to manually change them every time.

### Advanced Structure

We have designed an extendable structure:

```ts
export type MixRequestResponse = Response | { content?: Response; [key: string]: any } | string;
```

Now you can use it like this:

```js
<ProChat
  request={async (messages) => {
    const text = await delay(
      `This is a simulated non-streaming message output. This session received ${messages.length} messages`,
    );
    return {
      content: new Response(text),
      id: 'only-you-love-me',
      role: 'user-King',
      keys: ['Ovo'],
    };
  }}
/>
```

We will read your object and place its Content into the data stream as usual; other structures will also be included as-is. There are two scenarios here:

- If the key-value pairs inserted are those originally intended by the framework (e.g., id, createAt, role), except for id which ensures unique search capabilities (you can use genMessageId), others will replace what was supposed to be generated.
- If the inserted keys do not belong to pre-generated ones, they will be added additionally.

You'll find that except for id, other contents are additionally passed in.

> You might notice an extra Meta field in OriginData; this is an old version compatibility scheme where both outer layer and Meta data are essentially identical. You can choose either one.

![](https://mdn.alipayobjects.com/huamei_re70wt/afts/img/A*QX7BR6hI6FYAAAAAAAAAAAAADmuEAQ/original)

### Signal Control & Additional Parameters

Besides messages as conversation context, there are two more parameters in request input:

- extra: Additional parameter content configurable via config. Params inside config serve as additional fields while others are general modal parameters which you may or may not useâ€”typically used with model switching or model parameter panels.
- signal: Network request control such as SSE passed into Http requests or fetch/request etc., allowing network disconnection upon stopping generation (prevents situations where frontend stops generating but interface remains connected).

```js
<ProChat
  config={{
    params: {
      userId: '123',
      extra: 'extra',
    }
  }}
  request={async (messages, extra, signal) => {
    const text = await delay(
      `This is a simulated non-streaming message output. This session received ${messages.length} messages`,
    );
    return {
      content: new Response(text),
      id: 'only-you-love-me',
      role: 'user-King',
      keys: ['Ovo'],
    };
  }}
/>
```
